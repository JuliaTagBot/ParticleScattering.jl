<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 1: Solving a Simple Multiple-Scattering Problem · ParticleScattering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParticleScattering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li class="current"><a class="toctext" href>Tutorial 1: Solving a Simple Multiple-Scattering Problem</a><ul class="internal"></ul></li><li><a class="toctext" href="../tutorial2/">Tutorial 2: Accelerating Solutions with FMM</a></li><li><a class="toctext" href="../tutorial_optim_angle/">Tutorial 3: Angle Optimization</a></li><li><a class="toctext" href="../tutorial_optim_radius/">Tutorial 4: Radius Optimization</a></li></ul></li><li><a class="toctext" href="../minimalNP/">Choosing Minimal N and P</a></li><li><a class="toctext" href="../incident_fields/">Incident Field Types</a></li><li><a class="toctext" href="../new_shapes/">Adding New Shapes</a></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Tutorial 1: Solving a Simple Multiple-Scattering Problem</a></li></ul><a class="edit-page" href="https://github.com/bblankrot/ParticleScattering.jl/blob/master/docs/src/tutorial1.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 1: Solving a Simple Multiple-Scattering Problem</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1:-Solving-a-Simple-Multiple-Scattering-Problem-1" href="#Tutorial-1:-Solving-a-Simple-Multiple-Scattering-Problem-1">Tutorial 1: Solving a Simple Multiple-Scattering Problem</a></h1><h4><a class="nav-anchor" id="Scattering-from-one-particle-1" href="#Scattering-from-one-particle-1">Scattering from one particle</a></h4><p>In order to speed up computations, ParticleScattering depends on grouping identical shapes (rotated versions of the same shape are considered identical). Thus solving multiple-scattering problems is syntactically similar to solving for a single particle.</p><p>In this example, we simulate TM plane-wave scattering (<span>$E_z = e^{ik(\cos \theta_i, \, \sin \theta_i) \cdot \mathbf{r}}$</span>) from a single rounded star, parametrized by the equation</p><div>\[(x(\theta), y(\theta)) = [R + d \cos(5\theta)](\cos \theta, \sin \theta), \quad
R = 0.1\lambda_0, d = 0.05\lambda_0,\]</div><p>which is supplied by <code>rounded_star</code>. For now, we discretize the shape with <code>N=260</code> nodes and <code>P=10</code> cylindrical harmonics &amp;ndash; for more information on the relationship between these parameters and the various resulting errors, see <a href="../minimalNP/#minimalNP-1">Choosing Minimal N and P</a>.</p><pre><code class="language-julia">λ0 = 1 #doesn&#39;t matter since everything is normalized to λ0
k0 = 2π/λ0
kin = 3k0
θ_i = 0.0 #incident wave is left-&gt;right
pw = PlaneWave(θ_i)
N = 260
P = 10
shapes = [rounded_star(0.1λ0, 0.05λ0, 5, N)]
ids = [1] # the particle at centers[1,:] has the parametrization shapes[ids[1]]
centers = [0.0 0.0] # our particle is centered at the origin
φs = [0.0] #zero rotation angle
sp = ScatteringProblem(shapes, ids, centers, φs)</code></pre><p>Now that the scattering problem is set up, we solve for the cylindrical harmonics coefficients and potential densities, respectively, by using</p><pre><code class="language-julia">beta,inner = solve_particle_scattering(k0, kin, P, sp, pw)</code></pre><p>These can be used to calculate the scattered field at any point in space using low-level function <code>scatteredfield</code>, or strictly outside the circle of radius <code>shapes[1].R</code> with <code>scattered_field_multipole</code>. For large numbers of calculation points, however, it is easier to use <code>calc_near_field</code> which performs <code>solve_particle_scattering</code> and calculates the total (incident + scattered) field at every point using the most appropriate method:</p><pre><code class="language-julia">#calculate field on the x-axis passing through the particle
points = [range(-0.5λ0, stop=0.5λ0, length=200)  zeros(200)]
u = calc_near_field(k0, kin, P, sp, points, pw)</code></pre><p>We use <code>PyPlot</code> to display the result:</p><pre><code class="language-julia">using PyPlot
plot(points[:,1]/λ0, abs.(u))</code></pre><p><img src="../assets/simple_tutorial_plot1.png" alt="simple_tutorial_plot1"/></p><p>Similarly, a 2D plot can be drawn of the total field around the scatterer:</p><pre><code class="language-julia">plot_near_field(k0, kin, P, sp, pw;
    x_points = 201, y_points = 201, border = 0.5λ0*[-1;1;-1;1])</code></pre><p><img src="../assets/simple_tutorial_plot2.png" alt="simple_tutorial_plot2"/></p><p><strong>Note:</strong> In practice, converting the shape potential densities to cylindrical harmonics is inefficient here as we only have one scatterer, and <code>get_potentialPW</code> would be more accurate. This is meant only as an introductory example to the ParticleScattering syntax.</p><h4><a class="nav-anchor" id="scattering_small_grid-1" href="#scattering_small_grid-1">Scattering from a small grid of particles</a></h4><p>Expanding the example above to a collection of different particles is straightforward:</p><pre><code class="language-julia">λ0 = 1 #doesn&#39;t matter since everything is normalized to λ0
k0 = 2π/λ0
kin = 3k0
θ_i = π/2 #incident wave is down-&gt;up

N_squircle = 200
N_star = 260
P = 10
shapes = [rounded_star(0.1λ0, 0.05λ0, 5, N_star);
            squircle(0.15λ0, N_squircle)]
ids = [1;2;2;1]
centers =  square_grid(2, 0.4λ0) #2x2 grid with distance 0.4λ0
φs = 2π*rand(4) #random rotation angles
sp = ScatteringProblem(shapes, ids, centers, φs)</code></pre><p>Looking at the <span>$4 \times 2$</span> array <code>centers</code>, the coordinates of the <code>m</code>-th shape are given by <code>centers[m,:]</code>, and its rotation angle is stored in <code>φs[m]</code>. Likewise, <code>ids[m]</code> tells us if the shape has parametrization <code>shapes[1]</code>  &amp;ndash; in this case a rounded star &amp;ndash; or <code>shapes[2]</code>, a squircle. It is  imperative that the order of these arrays remain consistent for the solver to correctly precompute the scattering matrix transformation for each particle. Furthermore, <code>shapes</code> should not contain copies of the same shape, as that will lead to unnecessary computations.</p><p>Plotting the near field with the code</p><pre><code class="language-julia">data = plot_near_field(k0, kin, P, sp, PlaneWave(θ_i))
colorbar()</code></pre><p>yields the following near-field plot:</p><p><img src="../assets/simple_tutorial_plot3.png" alt="simple_tutorial_plot3"/></p><p>The reason the plot is mostly dark is that <code>plot_near_field</code> automatically scales the colors up to the maximum value calculated, which in this case happens to be an artifact due to inaccurate calculations close to a particle boundary. While this issue can be somewhat alleviated by increasing <code>N</code>, it will remain due to the quadrature method used here. Fortunately, this does not affect the results off the shape boundaries, and can be safely ignored by calling <code>clim([0.0;4.0])</code>.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../tutorial2/"><span class="direction">Next</span><span class="title">Tutorial 2: Accelerating Solutions with FMM</span></a></footer></article></body></html>
