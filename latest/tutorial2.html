<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 2: Accelerating Solutions with FMM · ParticleScattering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParticleScattering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="tutorial1.html">Tutorial 1: Solving a Simple Multiple-Scattering Problem</a></li><li class="current"><a class="toctext" href="tutorial2.html">Tutorial 2: Accelerating Solutions with FMM</a><ul class="internal"></ul></li></ul></li><li><a class="toctext" href="minimalNP.html">Choosing Minimal N and P</a></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="tutorial2.html">Tutorial 2: Accelerating Solutions with FMM</a></li></ul><a class="edit-page" href="https://github.com/bblankrot/ParticleScattering.jl/blob/master/docs/src/tutorial2.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 2: Accelerating Solutions with FMM</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-2:-Accelerating-Solutions-with-FMM-1" href="#Tutorial-2:-Accelerating-Solutions-with-FMM-1">Tutorial 2: Accelerating Solutions with FMM</a></h1><p>In this tutorial, we examine scattering from several hundreds of particles, and use the built-in Fast Multipole Method (FMM) implementation to provide faster results. FMM groups nearby particles and approximates their cumulative effect on &quot;far&quot; particles. Here, the grouping is done by drawing a square grid over computational region encompassing the particles. The error of these approximations is fairly controllable, especially for mid- to high-frequency scattering.</p><p>Another difference between the direct and FMM solvers is that the latter requires an iterative solver for the system of equations (GMRES is used here). Thus a certain residual tolerance must be defined at which point the GMRES process terminates.</p><p>The scattering problem here is set up by</p><pre><code class="language-julia">using ParticleScattering, PyPlot
λ0 = 1 #doesn&#39;t matter since everything is normalized to λ0
k0 = 2π/λ0
kin = 3k0
θ_i = π/4 #incident wave e^{i k_0 (1/sqrt{2},1/sqrt{2}) \cdot \mathbf{r}}

N_squircle = 200
N_star = 210
P = 10

M = 20
shapes = [rounded_star(0.1λ0, 0.03λ0, 5, N_star);
            squircle(0.15λ0, N_squircle)]
centers =  square_grid(M, λ0) #MxM grid with distance λ0
ids = rand(1:2, M^2)
φs = 2π*rand(M^2) #random rotation angles
sp = ScatteringProblem(shapes, ids, centers, φs)</code></pre><p>To setup FMM, we use the constructor <code>FMMoptions</code> with the following options:</p><pre><code class="language-julia">FMM::Bool       # Is FMM used? (default: false)
nx::Integer     # number of groups in x direction (required if dx is not
                # specified)
dx::Real        # group height &amp; width (required if nx is not specified)
acc::Integer    # accuracy digits for translation truncation, and also for
                # GMRES if tol is not given (required)
tol::Real       # GMRES tolerance (default: 10^{-acc})
method::String  # method used: for now only &quot;pre&quot; (default: &quot;pre&quot;)</code></pre><p>For this problem, we choose <span>$6$</span> digits of accuracy and grouping into <span>$(M/2)^2$</span> boxes. The grouping can be viewed by calling <code>divideSpace</code>:</p><pre><code class="language-julia">fmm_options = FMMoptions(true, acc = 6, nx = div(M,2))
divideSpace(centers, fmm_options; drawGroups = true)</code></pre><p>In this plot, the red markers denote the group centers while stars denote particle centers (the particles can be drawn on top of this plot with <code>draw_shapes</code>). At first, it might look strange that most each particle lies outside the FMM group; however, the FMM is used only after the particles are converted to line sources, and are thus fully contained in the FMM grid.</p><p><img src="assets/fmm_tutorial_plot0.png" alt="fmm_tutorial_plot0"/></p><p>Calculating and plotting the near or far fields with FMM is just as in the <a href="tutorial1.html#scattering_small_grid-1">previous tutorial</a>, except we must supply the <code>FMMoptions</code> object:</p><pre><code class="language-julia">plot_near_field(k0, kin, P, sp, θ_i, opt = fmm_options,
                border = [-12;12;-10;10], x_points = 480, y_points = 400)
colorbar()</code></pre><p><img src="assets/fmm_tutorial_plot1.png" alt="fmm_tutorial_plot1"/></p><p><img src="assets/fmm_tutorial_plot2.png" alt="fmm_tutorial_plot2"/></p><p><strong>Note:</strong> Currently, FMM is used to accelerate the solution of the scattering problem, but not the field calculation in <code>plot_near_field</code>.</p><h4><a class="nav-anchor" id="Direct-vs.-FMM-timing-1" href="#Direct-vs.-FMM-timing-1">Direct vs. FMM timing</a></h4><h4><a class="nav-anchor" id="Which-is-more-accurate?-1" href="#Which-is-more-accurate?-1">Which is more accurate?</a></h4><p>Intuitively, the direct approach is more accurate than the FMM with its various approximations and iterative solution method. However, inaccuracies can arise in the direct solution of even the simplest scattering problems:</p><pre><code class="language-julia">k0 = 0.01
kin = 0.02
shapes = [squircle(1, 200)]
ids = [1;1]
centers = [0.0 0.0; 5.0 0.0]
phis = [0.0;0.0]
sp = ScatteringProblem(shapes, ids, centers, phis)
Pmax = 15</code></pre><p>We solve this problem using the direct approach and with FMM, and then compare both the multipole coefficients <span>$\beta$</span> and the resulting potential densities:</p><pre><code class="language-julia">betas = Array{Vector}(Pmax)
betas_FMM = Array{Vector}(Pmax)
inners = Array{Vector}(Pmax)
inners_FMM = Array{Vector}(Pmax)
fmmopts = ParticleScattering.FMMoptions(true, nx = 1, acc = 9)
for P = 1:Pmax
	betas[P], inners[P] = solve_particle_scattering(k0, kin, P, sp, 0.0;
                            verbose = false)
	res, inners_FMM[P] = solve_particle_scattering_FMM(k0, kin, P, sp, 0.0,
                            fmmopts; verbose = false)
	betas_FMM[P] = res[1]
end

errnorm(x,y) = norm(x-y)/norm(x)

figure()
subplot(2,1,1)
semilogy([errnorm(betas_FMM[i], betas[i]) for i = 1:Pmax])
ylabel(&quot;\$\\Delta \\beta\$&quot;)
subplot(2,1,2)
semilogy([errnorm(inners_FMM[i], inners[i]) for i = 1:Pmax])
xlabel(&quot;\$ P \$&quot;)
ylabel(&quot;\$ \\Delta \$&quot; * &quot; Potential Density&quot;)</code></pre><p><img src="assets/direct_vs_fmm0.png" alt="direct_vs_fmm0"/></p><p>In both subplots, we see that increasing <code>P</code> actually leads to a decrease in accuracy (plotting the results separately also shows that the FMM results stay the same, while the direct results blow up). This is due to two main reasons - conditioning of the system matrix, and the fact that high-order cylindrical harmonics are responsible for substantially greater potential densities than lower-order ones. Both of these are impacted by the number of particles as well as the wavelength.</p><p>This ties in with <a href="minimalNP.html#minimalNP-1">Choosing Minimal N and P</a> &amp;ndash; not only does increasing <code>P</code> far beyond that required for a certain error impact runtime, but can also increase the error in the solution.</p><p>Of course, FMM was not really used here as <code>nx == 1</code> means both particles are in the same FMM group, and the maintained accuracy is purely due to the iterative system matrix solution used in <code>solve_particle_scattering_FMM</code>, GMRES.</p><footer><hr/><a class="previous" href="tutorial1.html"><span class="direction">Previous</span><span class="title">Tutorial 1: Solving a Simple Multiple-Scattering Problem</span></a><a class="next" href="minimalNP.html"><span class="direction">Next</span><span class="title">Choosing Minimal N and P</span></a></footer></article></body></html>
