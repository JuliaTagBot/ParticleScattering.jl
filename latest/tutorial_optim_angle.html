<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 3: Angle Optimization · ParticleScattering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParticleScattering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="tutorial1.html">Tutorial 1: Solving a Simple Multiple-Scattering Problem</a></li><li><a class="toctext" href="tutorial2.html">Tutorial 2: Accelerating Solutions with FMM</a></li><li class="current"><a class="toctext" href="tutorial_optim_angle.html">Tutorial 3: Angle Optimization</a><ul class="internal"></ul></li><li><a class="toctext" href="tutorial_optim_radius.html">Tutorial 4: Radius Optimization</a></li></ul></li><li><a class="toctext" href="minimalNP.html">Choosing Minimal N and P</a></li><li><a class="toctext" href="new_shapes.html">Adding New Shapes</a></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="tutorial_optim_angle.html">Tutorial 3: Angle Optimization</a></li></ul><a class="edit-page" href="https://github.com/bblankrot/ParticleScattering.jl/blob/master/docs/src/tutorial_optim_angle.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial 3: Angle Optimization</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-3:-Angle-Optimization-1" href="#Tutorial-3:-Angle-Optimization-1">Tutorial 3: Angle Optimization</a></h1><p>In this tutorial, we build upon the [previous tutorial]@(ref tutorial2) by optimizing the rotation angles of the particles (<code>φs</code>) to maximize the field intensity at a specific point. Depending on the scattering problem, wavelengths, and incident field, optimization can have a major or minor impact on the field. The simplest way to perform this optimization is by calling <a href="api.html#ParticleScattering.optimize_φ-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options,Any}"><code>optimize_φ</code></a>, which in turn utilizes <code>Optim</code>, a Julia package for nonlinear optimization. The type of objective function handled here is given by</p><div>\[f_{\mathrm{obj}} = \sum_{\mathbf{r} \in I} \| u(\mathbf{r})\|^2\]</div><p>where <span>$I$</span> is a set of points that lie outside all scattering discs and <span>$u$</span> is the <span>$z$</span>-component of the electric field. This function can be minimized directly, or maximized by minimizing <span>$-f_{\mathrm{obj}}$</span>.</p><p>First we set up our scattering problem:</p><pre><code class="language-julia">λ0 = 1 #doesn&#39;t matter since everything is normalized to λ0
k0 = 2π/λ0
kin = 0.5k0
θ_i = 0 #incident wave e^{i k_0 (1/sqrt{2},1/sqrt{2}) \cdot \mathbf{r}}
M = 20
shapes = [rounded_star(0.35λ0, 0.1λ0, 4, 202)]
P = 12
centers =  rect_grid(2, div(M,2), λ0, λ0) #2xM/2 grid
ids = ones(Int, M)
φs0 = zeros(M)
sp = ScatteringProblem(shapes, ids, centers, φs0)
fmm_options = FMMoptions(true, acc = 6, dx = 2λ0)
points = 0.05*λ0*[-1 0; 1 0; 0 1; 0 -1]</code></pre><p>where <code>φs0</code> is the starting point for the optimization method, and <code>points</code> are the locations at which we intend to maximize or minimize the field intensity. In this case, we want to optimize intensity at a small area around the origin. We now select the optimization method and select its options. In most cases, this combination of BFGS with a backtracking line search will yield accurate results in fast time; other line searches that require re-evaluation of the gradient will be significantly slower but may converge more accurately. The possible convergence criteria are set by the bounds <code>f_tol</code>, <code>g_tol</code>, and <code>x_tol</code>, for a relative change in the function, gradient norm, or variables, respectively. In addition, we can set a maximum number of <code>iterations</code>. Verbosity of the output is set with <code>show_trace</code> and <code>extended_trace</code>.</p><pre><code class="language-julia">optim_options = Optim.Options(f_tol = 1e-6, iterations = 100,
                    store_trace = true, show_trace = true)
optim_method = Optim.BFGS(;linesearch = LineSearches.BackTracking())</code></pre><p>We now run both minimization and maximization:</p><pre><code class="language-julia">res_min = optimize_φ(φs0, points, P, θ_i, k0, kin, shapes, centers, ids,
            fmm_options, optim_options, optim_method; minimize = true)
res_max = optimize_φ(φs0, points, P, θ_i, k0, kin, shapes, centers, ids,
            fmm_options, optim_options, optim_method; minimize = false)
sp_min = ScatteringProblem(shapes, ids, centers, res_min.minimizer)
sp_max = ScatteringProblem(shapes, ids, centers, res_max.minimizer)</code></pre><p>Once the optimization is done, we can visualize each <code>ScatteringProblem</code> separately with <a href="api.html#ParticleScattering.plot_near_field"><code>plot_near_field</code></a> or compare them side by side with the following PyPlot code:</p><pre><code class="language-julia">plts = Array{Any}(3)
plts[1] = plot_near_field(k0, kin, P, sp, θ_i, x_points = 100, y_points = 300,
        opt = fmm_options, border = find_border(sp, points))
plts[2] = plot_near_field(k0, kin, P, sp_min, θ_i, x_points = 100, y_points = 300,
        opt = fmm_options, border = find_border(sp, points))
plts[3] = plot_near_field(k0, kin, P, sp_max, θ_i, x_points = 100, y_points = 300,
        opt = fmm_options, border = find_border(sp, points))
close(&quot;all&quot;)

fig, axs = subplots(ncols=3); msh = 0
for (i, spi) in enumerate([sp;sp_min;sp_max])
    msh = axs[i][:pcolormesh](plts[i][2][1], plts[i][2][2], abs.(plts[i][2][3]),
                        vmin = 0, vmax = 3.4, cmap=&quot;viridis&quot;)
    draw_shapes(spi.shapes, spi.centers, spi.ids, spi.φs, axs[i])
    axs[i][:set_aspect](&quot;equal&quot;, adjustable = &quot;box&quot;)
    axs[i][:set_xlim]([border[1];border[2]])
    axs[i][:set_ylim]([border[3];border[4]])
    axs[i][:set_xticks]([-1,0,1])
    i &gt; 1 &amp;&amp; axs[i][:set_yticks]([])
end
subplots_adjust(left=0.05, right=0.8, top=0.98, bottom = 0.05, wspace = 0.1)
cbar_ax = fig[:add_axes]([0.85, 0.05, 0.05, 0.93])
fig[:colorbar](msh, cax=cbar_ax)</code></pre><div style="text-align:center">
<img alt=optim_angle src="./assets/optim_angle.png" style="width:80%; height:auto; margin:1%; max-width: 600px">
</div><p style="clear:both;"><p>From left to right, we see the electric field before optimization, after minimization, and after maximization. The field intensity at the origin is notably different in both optimization results, with minimization decreasing the intensity by 95%, and maximization increasing it by over 700%. The convergence of the optimization method for both examples can be plotted via:</p><pre><code class="language-julia">iters = length(res_min.trace)
fobj = [res_min.trace[i].value for i=1:iters]
gobj = [res_min.trace[i].g_norm for i=1:iters]
iters2 = length(res_max.trace)
fobj2 = -[res_max.trace[i].value for i=1:iters2]
gobj2 = [res_max.trace[i].g_norm for i=1:iters2]

fig, axs = subplots(ncols=2, figsize=[7,5])
axs[1][:semilogy](0:iters-1, fobj, linewidth=2)
axs[2][:semilogy](0:iters-1, gobj, linewidth=2)
axs[1][:semilogy](0:iters2-1, fobj2, linewidth=2, &quot;--&quot;)
axs[2][:semilogy](0:iters2-1, gobj2, linewidth=2, &quot;--&quot;)
axs[1][:legend]([&quot;\$f_\\mathrm{obj}\$ (min)&quot;;
                &quot;\$f_\\mathrm{obj}\$ (max)&quot;], loc=&quot;right&quot;)
axs[2][:legend]([&quot;\$\\|\\mathbf{g}_\\mathrm{obj}\\|\$ (min)&quot;;
                &quot;\$\\|\\mathbf{g}_\\mathrm{obj}\\|\$ (max)&quot;], loc=&quot;best&quot;)
axs[1][:set_xlabel](&quot;Iteration&quot;)
axs[2][:set_xlabel](&quot;Iteration&quot;)
axs[1][:set_ylim](ymax=40)</code></pre><p style="text-align:center;"><img alt=optim_angle_conv src="./assets/optim_angle_conv.png" style="width:70%; height:auto; max-width:600px"></p><footer><hr/><a class="previous" href="tutorial2.html"><span class="direction">Previous</span><span class="title">Tutorial 2: Accelerating Solutions with FMM</span></a><a class="next" href="tutorial_optim_radius.html"><span class="direction">Next</span><span class="title">Tutorial 4: Radius Optimization</span></a></footer></article></body></html>
