<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ParticleScattering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ParticleScattering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="tutorial1.html">Tutorial 1: Solving a Simple Multiple-Scattering Problem</a></li><li><a class="toctext" href="tutorial2.html">Tutorial 2: Accelerating Solutions with FMM</a></li><li><a class="toctext" href="tutorial_optim_angle.html">Tutorial 3: Angle Optimization</a></li><li><a class="toctext" href="tutorial_optim_radius.html">Tutorial 4: Radius Optimization</a></li></ul></li><li><a class="toctext" href="minimalNP.html">Choosing Minimal N and P</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#User-Interface-1">User Interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/bblankrot/ParticleScattering.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h1><ul><li><a href="api.html#ParticleScattering"><code>ParticleScattering</code></a></li><li><a href="api.html#ParticleScattering.R_multipole"><code>ParticleScattering.R_multipole</code></a></li><li><a href="api.html#ParticleScattering.AbstractShapeParams"><code>ParticleScattering.AbstractShapeParams</code></a></li><li><a href="api.html#ParticleScattering.CircleParams"><code>ParticleScattering.CircleParams</code></a></li><li><a href="api.html#ParticleScattering.FMMoptions"><code>ParticleScattering.FMMoptions</code></a></li><li><a href="api.html#ParticleScattering.OptimBuffer"><code>ParticleScattering.OptimBuffer</code></a></li><li><a href="api.html#ParticleScattering.ScatteringProblem"><code>ParticleScattering.ScatteringProblem</code></a></li><li><a href="api.html#ParticleScattering.ShapeParams"><code>ParticleScattering.ShapeParams</code></a></li><li><a href="api.html#ParticleScattering.calc_near_field-Tuple{Any,Any,Any,ParticleScattering.ScatteringProblem,Any,Any}"><code>ParticleScattering.calc_near_field</code></a></li><li><a href="api.html#ParticleScattering.draw_shapes"><code>ParticleScattering.draw_shapes</code></a></li><li><a href="api.html#ParticleScattering.ellipse-Tuple{Any,Any,Any}"><code>ParticleScattering.ellipse</code></a></li><li><a href="api.html#ParticleScattering.find_border-Tuple{ParticleScattering.ScatteringProblem,Array{Float64,2}}"><code>ParticleScattering.find_border</code></a></li><li><a href="api.html#ParticleScattering.find_border-Tuple{ParticleScattering.ScatteringProblem}"><code>ParticleScattering.find_border</code></a></li><li><a href="api.html#ParticleScattering.get_potential-NTuple{6,Any}"><code>ParticleScattering.get_potential</code></a></li><li><a href="api.html#ParticleScattering.get_potential-Tuple{Any,Any,Any,ParticleScattering.ShapeParams}"><code>ParticleScattering.get_potential</code></a></li><li><a href="api.html#ParticleScattering.get_potentialPW-NTuple{4,Any}"><code>ParticleScattering.get_potentialPW</code></a></li><li><a href="api.html#ParticleScattering.luneburg_grid-Tuple{Any,Any,Any}"><code>ParticleScattering.luneburg_grid</code></a></li><li><a href="minimalNP.html#ParticleScattering.minimumN"><code>ParticleScattering.minimumN</code></a></li><li><a href="api.html#ParticleScattering.minimumN-Tuple{Any,Any,Any}"><code>ParticleScattering.minimumN</code></a></li><li><a href="api.html#ParticleScattering.minimumP-Tuple{Any,Any,ParticleScattering.ShapeParams}"><code>ParticleScattering.minimumP</code></a></li><li><a href="api.html#ParticleScattering.optimize_radius-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options}"><code>ParticleScattering.optimize_radius</code></a></li><li><a href="api.html#ParticleScattering.optimize_φ-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options,Any}"><code>ParticleScattering.optimize_φ</code></a></li><li><a href="api.html#ParticleScattering.plot_far_field"><code>ParticleScattering.plot_far_field</code></a></li><li><a href="api.html#ParticleScattering.plot_near_field"><code>ParticleScattering.plot_near_field</code></a></li><li><a href="api.html#ParticleScattering.randpoints-NTuple{4,Any}"><code>ParticleScattering.randpoints</code></a></li><li><a href="api.html#ParticleScattering.randpoints-NTuple{5,Any}"><code>ParticleScattering.randpoints</code></a></li><li><a href="api.html#ParticleScattering.rect_grid-Tuple{Integer,Integer,Any,Any}"><code>ParticleScattering.rect_grid</code></a></li><li><a href="api.html#ParticleScattering.rounded_star-NTuple{4,Any}"><code>ParticleScattering.rounded_star</code></a></li><li><a href="api.html#ParticleScattering.scatteredfield-Tuple{Any,Any,ParticleScattering.ShapeParams,Any}"><code>ParticleScattering.scatteredfield</code></a></li><li><a href="api.html#ParticleScattering.scatteredfield-NTuple{6,Any}"><code>ParticleScattering.scatteredfield</code></a></li><li><a href="api.html#ParticleScattering.solve_particle_scattering"><code>ParticleScattering.solve_particle_scattering</code></a></li><li><a href="api.html#ParticleScattering.solve_particle_scattering_FMM-Tuple{Any,Any,Any,ParticleScattering.ScatteringProblem,Any,ParticleScattering.FMMoptions}"><code>ParticleScattering.solve_particle_scattering_FMM</code></a></li><li><a href="api.html#ParticleScattering.square_grid-Tuple{Integer,Any}"><code>ParticleScattering.square_grid</code></a></li><li><a href="api.html#ParticleScattering.squircle-Tuple{Any,Any}"><code>ParticleScattering.squircle</code></a></li><li><a href="api.html#ParticleScattering.uniqueind-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>ParticleScattering.uniqueind</code></a></li><li><a href="api.html#ParticleScattering.verify_min_distance-Tuple{Any,Array{Float64,2},Any,Array{Float64,2}}"><code>ParticleScattering.verify_min_distance</code></a></li><li><a href="api.html#ParticleScattering.verify_min_distance-Tuple{Any,Array{Float64,2},Any}"><code>ParticleScattering.verify_min_distance</code></a></li></ul><h1><a class="nav-anchor" id="User-Interface-1" href="#User-Interface-1">User Interface</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering" href="#ParticleScattering"><code>ParticleScattering</code></a> — <span class="docstring-category">Module</span>.</div><div><p>A Julia package for solving large-scale electromagnetic scattering problems in two dimensions; specifically, those containing a large number of penetrable smooth particles. Provides the ability to optimize over the particle parameters for various design problems.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/ParticleScattering.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.R_multipole" href="#ParticleScattering.R_multipole"><code>ParticleScattering.R_multipole</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>R_multipole = 1.1 is the constant ratio between scattering disks and the maximal radius of their particles, and thus half the minimal distance between neighboring particles. While mathematically this can be reduced to <code>1 + eps()</code>, that will increase the necessary <code>P</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.AbstractShapeParams" href="#ParticleScattering.AbstractShapeParams"><code>ParticleScattering.AbstractShapeParams</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractShapeParams</code></pre><p>Abstract type which all shape types inherit from.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.CircleParams" href="#ParticleScattering.CircleParams"><code>ParticleScattering.CircleParams</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CircleParams(R)</code></pre><p>Returns object for a circular shape, containing its radius in the field <code>R</code> (which is also the radius of the scattering disk).</p><p>See also: <code>ShapeParams</code>,<code>R_multipole</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L35-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.FMMoptions" href="#ParticleScattering.FMMoptions"><code>ParticleScattering.FMMoptions</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FMMoptions(FMM; nx = 0, dx = 0.0, acc = 0, tol = 0.0, method = &quot;pre&quot;)</code></pre><p>Constructor for <code>struct</code> containing all FMM options. <code>FMM</code> decides if FMM is used, and the following keyword arguments dictate its behavior:</p><ul><li><p><code>nx::Integer</code>: number of groups in x direction (for division)</p></li><li><p><code>dx::Real</code>: group height/width (alternative division)</p></li><li><p><code>acc::Integer</code>: accuracy digits for translation truncation, and also for gmres if <code>tol</code> is not given</p></li><li><p><code>tol::Real</code>: gmres tolerance</p></li><li><p><code>method::String</code>: method used: for now can be &quot;pre&quot; or &quot;pre2&quot;. Mainly used for development.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L85-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.OptimBuffer" href="#ParticleScattering.OptimBuffer"><code>ParticleScattering.OptimBuffer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">OptimBuffer(Ns::Integer, P::Integer, Npoints::Integer, [J::Integer])</code></pre><p>Constructor for the <code>OptimBuffer</code> type, which stores some of the buffers and shared variables necessary for optimization. Includes the cylindrical harmonics coefficient vector <code>β</code>, field values at points of interest (<code>f</code>), the partial derivatives <code>∂β</code>, and storage for the various right-hand side vectors used while solving for <code>∂β</code>.</p><p>If the number of optimization variables <code>J</code> is not supplied, it is assumed that <code>J</code> = <code>Ns</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L131-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.ScatteringProblem" href="#ParticleScattering.ScatteringProblem"><code>ParticleScattering.ScatteringProblem</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScatteringProblem(shapes, ids, centers, φs)</code></pre><p>Constructor for the <code>ScatteringProblem</code> type, including particle shape information for multiple-scattering problems.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L156-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.ShapeParams" href="#ParticleScattering.ShapeParams"><code>ParticleScattering.ShapeParams</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ShapeParams(t,ft,dft)</code></pre><p>Returns <code>ShapeParams</code> object containing the parametrization of a two-dimensional shape. <code>t</code> is a uniform sampling of [0,2π), <code>ft = [x(t) y(t)]</code>, and <code>dft = [x&#39;(t) y&#39;(t)]</code>. The field <code>R</code> contains the radius of the shape&#39;s scattering disk.</p><p>See also: <code>CircleParams</code>,<code>R_multipole</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/PS_types.jl#L16-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.calc_near_field-Tuple{Any,Any,Any,ParticleScattering.ScatteringProblem,Any,Any}" href="#ParticleScattering.calc_near_field-Tuple{Any,Any,Any,ParticleScattering.ScatteringProblem,Any,Any}"><code>ParticleScattering.calc_near_field</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">calc_near_field(k0, kin, P, sp::ScatteringProblem, points, θ_i;
                        opt::FMMoptions = FMMoptions(), use_multipole = true,
                        verbose = true)</code></pre><p>Calculates the total electric field as a result of a plane wave with incident angle <code>θ_i</code> scattering from the ScatteringProblem <code>sp</code>, at <code>points</code>. Uses the FMM options given by <code>opt</code> (default behavious is disabled FMM); <code>use_multipole</code> dictates whether electric field is calculated using the multipole/cylindrical harmonics (true) or falls back on potential densities (false). Either way, the multiple-scattering system is solved in the cylindrical harmonics space, and the field by a particular scatterer inside its own scattering discs is calculated by potential densities, as the cylindrical harmonics approximation is not valid there.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/visualization.jl#L124-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.draw_shapes" href="#ParticleScattering.draw_shapes"><code>ParticleScattering.draw_shapes</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">draw_shapes(shapes, centers, ids, φs, ax = gca())</code></pre><p>Draws all of the shapes in a given scattering problem. Parametrized shapes are drawn as polygons while circles are drawn using matplotlib&#39;s <code>patch.Circle</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/visualization.jl#L97-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.ellipse-Tuple{Any,Any,Any}" href="#ParticleScattering.ellipse-Tuple{Any,Any,Any}"><code>ParticleScattering.ellipse</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ellipse(r1, r2, N)</code></pre><p>Return a <code>ShapeParams</code> object containing the shape parametrized by <code>(x/r1)^2 + (y/r2)^2 = 1</code> with 2<code>N</code> nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L36-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.find_border-Tuple{ParticleScattering.ScatteringProblem,Array{Float64,2}}" href="#ParticleScattering.find_border-Tuple{ParticleScattering.ScatteringProblem,Array{Float64,2}}"><code>ParticleScattering.find_border</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find_border(sp::ScatteringProblem, points::Array{Float64,2}) -&gt; [x_min; x_max; y_min; y_max]</code></pre><p>Returns bounding box that contains all of the shapes in <code>sp</code> as well as specified <code>points</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/utilities.jl#L94-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.find_border-Tuple{ParticleScattering.ScatteringProblem}" href="#ParticleScattering.find_border-Tuple{ParticleScattering.ScatteringProblem}"><code>ParticleScattering.find_border</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">find_border(sp::ScatteringProblem) -&gt; [x_min; x_max; y_min; y_max]</code></pre><p>Returns bounding box that contains all of the shapes in <code>sp</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/utilities.jl#L82-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.get_potential-NTuple{6,Any}" href="#ParticleScattering.get_potential-NTuple{6,Any}"><code>ParticleScattering.get_potential</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_potential(kout, kin, P, s::ShapeParams) -&gt; sigma_mu</code></pre><p>Given a shape <code>s</code> with <code>2N</code> discretization nodes, outer and inner wavenumbers <code>kout</code>,<code>kin</code>, and the cylindrical harmonics parameter <code>P</code>, returns the potential densities <code>sigma_mu</code>. Each column contains the response to a different harmonic, where the first <code>2N</code> entries contain the single-layer potential density (<span>$sigma$</span>), and the lower entries contain the double-layer density (<span>$mu$</span>).</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/scattering.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.get_potential-Tuple{Any,Any,Any,ParticleScattering.ShapeParams}" href="#ParticleScattering.get_potential-Tuple{Any,Any,Any,ParticleScattering.ShapeParams}"><code>ParticleScattering.get_potential</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_potential(kout, kin, P, t, ft, dft) -&gt; sigma_mu</code></pre><p>Same, but with the <code>ShapeParams</code> supplied directly.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/scattering.jl#L42-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.get_potentialPW-NTuple{4,Any}" href="#ParticleScattering.get_potentialPW-NTuple{4,Any}"><code>ParticleScattering.get_potentialPW</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_potentialPW(kout, kin, s::ShapeParams, θ_i) -&gt; sigma_mu</code></pre><p>Given a shape <code>s</code> with <code>2N</code> discretization nodes, outer and inner wavenumbers <code>kout</code>,<code>kin</code>, and an incident plane-wave angle, returns the potential densities vector <code>sigma_mu</code>. The first <code>2N</code> entries contain the single-layer potential density (<span>$sigma$</span>), and the lower entries contain the double-layer density (<span>$mu$</span>).</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/scattering.jl#L133-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.luneburg_grid-Tuple{Any,Any,Any}" href="#ParticleScattering.luneburg_grid-Tuple{Any,Any,Any}"><code>ParticleScattering.luneburg_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">luneburg_grid(R_lens, N_cells, er; levels = 0, TM = true) -&gt; centers, ids, rs</code></pre><p>Returns the coordinates and radii of the circular inclusions in a Luneburg lens device of radius <code>R_lens</code> with <code>N_cells</code> unit cells across its diameter. Radii are determined by averaging over cell permittivity, assuming air outside and relative permittivity <code>er</code> in the rods, and depends on incident field polarization (TM/TE with respect to z-axis). If <code>levels</code> == 0, groups identical radii together, such that rs[ids[n]] is the radius of the rod centered at <code>(center[n,1],center[n,2])</code>. Otherwise quantizes the radii to uniformly spaced levels.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L215-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.minimumN-Tuple{Any,Any,Any}" href="#ParticleScattering.minimumN-Tuple{Any,Any,Any}"><code>ParticleScattering.minimumN</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minimumN(kout, kin, shape_function; tol = 1e-9, N_points = 10_000,
    N_start = 400, N_min = 100, N_max = 1_000) -&gt; N, err</code></pre><p>Return the minimum <code>N</code> necessary (i.e. <code>2N</code> nodes) to achieve error of at most <code>tol</code> in the electric field for a <code>ShapeParams</code> inclusion created by <code>shape_function(N)</code> which is filled with material of wavenumber <code>kin</code> and surrounded by free space with wavenumber <code>k0</code>. Error is calculated on <code>N_points</code> points on the scattering disk (<code>s.R</code>), by assuming a fictitious line source and comparing its field to that produced by the resulting potential densities.</p><p>Since the error scales with <span>$N^{-3}$</span> for moderate wavelengths and errors, we estimate <code>N</code> using the error of <code>N_start</code>, then binary search based on that guess between <code>N_min</code> and <code>N_max</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/minimum_N_P.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.minimumP-Tuple{Any,Any,ParticleScattering.ShapeParams}" href="#ParticleScattering.minimumP-Tuple{Any,Any,ParticleScattering.ShapeParams}"><code>ParticleScattering.minimumP</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">minimumP(k0, kin, s::ShapeParams; tol = 1e-9, N_points = 10_000, P_min = 1,
    P_max = 60, dist = 2) -&gt; P, errP</code></pre><p>Return the minimum <code>P</code> necessary to achieve error of at most <code>tol</code> in the electric field, when compared to that obtained with <code>2N</code> discretization, for a <code>ShapeParams</code> inclusion filled with material of wavenumber <code>kin</code> and surrounded by free space with wavenumber <code>k0</code>. Error is calculated on <code>N_points</code> points on a disk of radius <code>dist*s.R</code>.</p><p>Uses binary search between <code>P_min</code> and <code>P_max</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/minimum_N_P.jl#L68-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.optimize_radius-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options}" href="#ParticleScattering.optimize_radius-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options}"><code>ParticleScattering.optimize_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">optimize_radius(rs0, r_min, r_max, points, ids, P, θ_i, k0, kin, centers,
    fmmopts, optimopts::Optim.Options; minimize = true, method = &quot;BFGS&quot;)</code></pre><p>Optimize the radii of circular particles for minimization or maximization of the field intensity at <code>points</code>, depending on <code>minimize</code>. Uses <code>Optim</code>&#39;s <code>Fminbox</code> box-contrained optimization to contain radii in feasible rangle, given in scalar or vector form by <code>r_min</code> and <code>r_max</code>.</p><p>Here, <code>ids</code> allows for grouping particles - for example, to maintain symmetry of the optimized device. <code>optimopts</code> defines the convergence criteria and other optimization parameters for both the inner and outer iterations. <code>method</code> can be either <code>&quot;BFGS&quot;</code> or <code>&quot;LBFGS&quot;</code>. See the <code>Optim.Fminbox</code> documentation for more details.</p><p>Returns an object of type <code>Optim.MultivariateOptimizationResults</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/optimize_rs.jl#L1-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.optimize_φ-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options,Any}" href="#ParticleScattering.optimize_φ-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Optim.Options,Any}"><code>ParticleScattering.optimize_φ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">optimize_φ(φs0, points, P, θ_i, k0, kin, shapes, centers, ids, fmmopts,
    optimopts::Optim.Options, minimize = true)</code></pre><p>Optimize the rotation angles of a particle collection for minimization or maximization (depending on <code>minimize</code>) of the field intensity at <code>points</code>. <code>optimopts</code> and <code>method</code> define the optimization method, convergence criteria, and other optimization parameters. Returns an object of type <code>Optim.MultivariateOptimizationResults</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/optimize_phis.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.plot_far_field" href="#ParticleScattering.plot_far_field"><code>ParticleScattering.plot_far_field</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plot_far_field(k0, kin, P, sp::ScatteringProblem, θ_i = 0;
                    opt::FMMoptions = FMMoptions(), use_multipole = true,
                    plot_points = 200)</code></pre><p>Plots the echo width (radar cross section in two dimensions) for a given scattering problem. <code>opt</code>, <code>use_multipole</code> are as in <code>plot_near_field</code>. Also returns the echo width.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/visualization.jl#L57-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.plot_near_field" href="#ParticleScattering.plot_near_field"><code>ParticleScattering.plot_near_field</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plot_near_field(k0, kin, P, sp::ScatteringProblem, θ_i = 0;
                    opt::FMMoptions = FMMoptions(), use_multipole = true,
                    x_points = 201, y_points = 201, border = find_border(sp),
                    normalize = 1.0)</code></pre><p>Plots the total electric field as a result of a plane wave with incident angle <code>θ_i</code> scattering from the ScatteringProblem <code>sp</code>, using matplotlib&#39;s <code>pcolormesh</code>. Can accept number of sampling points in each direction plus bounding box or calculate automatically.</p><p>Uses the FMM options given by <code>opt</code> (FMM is disabled by default); <code>use_multipole</code> dictates whether electric field is calculated using the multipole/cylindrical harmonics (true) or falls back on potential densities (false). Either way, the multiple-scattering system is solved in the cylindrical harmonics space. Normalizes all distances and sizes in plot (but not output) by <code>normalize</code>.</p><p>Returns the calculated field in two formats:</p><ol><li><p><code>(points, Ez)</code> where <code>Ez[i]</code> is the total electric field at <code>points[i,:]</code>, and</p></li><li><p><code>(xgrid,ygrid,zgrid)</code>, the format suitable for <code>pcolormesh</code>, where <code>zgrid[i,j]</code></p></li></ol><p>contains the field at <code>(mean(xgrid[i, j:j+1]), mean(ygrid[i:i+1, j]))</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/visualization.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.randpoints-NTuple{4,Any}" href="#ParticleScattering.randpoints-NTuple{4,Any}"><code>ParticleScattering.randpoints</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">randpoints(M, dmin, width, height; failures = 100)</code></pre><p>Return <code>centers</code>, an <code>(M,2)</code> array containing <code>M</code> points distanced at least <code>dmin</code> in a <code>width</code> by <code>height</code> box. Fails <code>failures</code> times successively before giving up.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L78-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.randpoints-NTuple{5,Any}" href="#ParticleScattering.randpoints-NTuple{5,Any}"><code>ParticleScattering.randpoints</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">randpoints(M, dmin, width, height, points; failures = 100)</code></pre><p>Same as randpoints(M, dmin, width, height; failures = 100) but also requires centers to be distanced at least <code>dmin</code> from <code>points</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L119-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.rect_grid-Tuple{Integer,Integer,Any,Any}" href="#ParticleScattering.rect_grid-Tuple{Integer,Integer,Any,Any}"><code>ParticleScattering.rect_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rect_grid(a::Integer, b::Integer, dx, dy)</code></pre><p>Return <code>centers</code>, an <code>(a*b,2)</code> array containing the points spanned by <code>a</code> points distanced <code>dx</code> and <code>b</code> points distanced <code>dy</code>, in the x and y directions, respectively.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L62-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.rounded_star-NTuple{4,Any}" href="#ParticleScattering.rounded_star-NTuple{4,Any}"><code>ParticleScattering.rounded_star</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rounded_star(r, d, num, N)</code></pre><p>Return a <code>ShapeParams</code> object containing the shape parametrized by <span>$(x(θ),y(θ)) = (r + d*cos(θ*num))*(cos(θ),sin(θ))$</span> with 2<code>N</code> nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.scatteredfield-NTuple{6,Any}" href="#ParticleScattering.scatteredfield-NTuple{6,Any}"><code>ParticleScattering.scatteredfield</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">scatteredfield(sigma_mu, k, t, ft, dft, p) -&gt; u_s</code></pre><p>Same, but with the <code>ShapeParams</code> supplied directly. Useful for computing <code>u_s</code> for rotated shapes.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/scattering.jl#L167-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.scatteredfield-Tuple{Any,Any,ParticleScattering.ShapeParams,Any}" href="#ParticleScattering.scatteredfield-Tuple{Any,Any,ParticleScattering.ShapeParams,Any}"><code>ParticleScattering.scatteredfield</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">scatteredfield(sigma_mu, k, s::ShapeParams, p) -&gt; u_s</code></pre><p>Computes field scattered by the particle <code>s</code> with pre-computed potential densities <code>sigma_mu</code> at points <code>p</code>. All points must either be inside <code>k = kin</code> or outside <code>k = kout</code> the particle.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/scattering.jl#L157-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.solve_particle_scattering" href="#ParticleScattering.solve_particle_scattering"><code>ParticleScattering.solve_particle_scattering</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solve_particle_scattering(k0, kin, P, sp::ScatteringProblem, θ_i = 0.0; get_inner = true, verbose = true) -&gt; beta, inner</code></pre><p>Solve the scattering problem <code>sp</code> with outer wavenumber <code>k0</code>, inner wavenumber <code>kin</code>, <code>2P+1</code> cylindrical harmonics per inclusion and incident plane wave angle <code>θ_i</code>. Solves multiple-scattering equation directly. Returns the cylindrical harmonics basis <code>beta</code> along with potential densities (in case of arbitrary inclusion) or inner cylindrical coefficients (in case of circular). By default, incident wave propagates left-&gt;right.</p><p>Inner coefficients are only calculated if <code>get_inner</code> is true, and timing is printed if <code>verbose</code> is true.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/multipole.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.solve_particle_scattering_FMM-Tuple{Any,Any,Any,ParticleScattering.ScatteringProblem,Any,ParticleScattering.FMMoptions}" href="#ParticleScattering.solve_particle_scattering_FMM-Tuple{Any,Any,Any,ParticleScattering.ScatteringProblem,Any,ParticleScattering.FMMoptions}"><code>ParticleScattering.solve_particle_scattering_FMM</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">solve_particle_scattering_FMM(k0, kin, P, sp::ScatteringProblem, θ_i, opt::FMMoptions; plot_res = false, get_inner = true, verbose = true) -&gt; result, inner</code></pre><p>Solve the scattering problem <code>sp</code> with outer wavenumber <code>k0</code>, inner wavenumber <code>kin</code>, <code>2P+1</code> cylindrical harmonics per inclusion and incident plane wave angle <code>θ_i</code>. Utilizes FMM with options <code>opt</code> to solve multiple-scattering equation. Returns the cylindrical harmonics basis <code>beta</code> along with convergence data in <code>result</code>. <code>inner</code> contains potential densities (in case of arbitrary inclusion) or inner cylindrical coefficients (in case of circular).</p><p><code>plot_res</code> controls plotting of the residual. Inner coefficients are calculated only if <code>get_inner</code> is true, and timing is printed if <code>verbose</code> is true.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/fmm_main.jl#L1-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.square_grid-Tuple{Integer,Any}" href="#ParticleScattering.square_grid-Tuple{Integer,Any}"><code>ParticleScattering.square_grid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">square_grid(a::Integer, d)</code></pre><p>Return <code>centers</code>, an <code>(a^2,2)</code> array containing the points on an <code>a</code> by <code>a</code> grid of points distanced <code>d</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L50-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.squircle-Tuple{Any,Any}" href="#ParticleScattering.squircle-Tuple{Any,Any}"><code>ParticleScattering.squircle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">squircle(r, N)</code></pre><p>Return a <code>ShapeParams</code> object containing the shape parametrized by <span>$x(θ)^4 + y(θ)^4 = r^4$</span> with 2<code>N</code> nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.uniqueind-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#ParticleScattering.uniqueind-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>ParticleScattering.uniqueind</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">uniqueind(v::Vector{T}) where T &lt;: Number -&gt; inds,u</code></pre><p>Given a vector of numbers <code>v</code> of length <code>n</code>, returns the unique subset <code>u</code> as well as a vector of indices <code>inds</code> of length <code>n</code> such that <code>v == u[inds]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/utilities.jl#L58-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.verify_min_distance-Tuple{Any,Array{Float64,2},Any,Array{Float64,2}}" href="#ParticleScattering.verify_min_distance-Tuple{Any,Array{Float64,2},Any,Array{Float64,2}}"><code>ParticleScattering.verify_min_distance</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">verify_min_distance(shapes, centers::Array{Float64,2}, ids, points::Array{Float64,2})
verify_min_distance(sp::ScatteringProblem, points)</code></pre><p>Returns <code>true</code> if the shapes placed at <code>centers</code> are properly distanced (non-intersecting scattering disks), and all <code>points</code> are outside the scattering disks.</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L186-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ParticleScattering.verify_min_distance-Tuple{Any,Array{Float64,2},Any}" href="#ParticleScattering.verify_min_distance-Tuple{Any,Array{Float64,2},Any}"><code>ParticleScattering.verify_min_distance</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">verify_min_distance(shapes, centers::Array{Float64,2}, ids)
verify_min_distance(sp::ScatteringProblem)</code></pre><p>Returns <code>true</code> if the shapes placed at <code>centers</code> are properly distanced (non-intersecting scattering disks).</p></div><a class="source-link" target="_blank" href="https://github.com/bblankrot/ParticleScattering.jl/blob/b576f2d35aa02c321a5fecc1fe1be4cf83888326/src/shapes.jl#L170-L175">source</a></section><footer><hr/><a class="previous" href="minimalNP.html"><span class="direction">Previous</span><span class="title">Choosing Minimal N and P</span></a></footer></article></body></html>
